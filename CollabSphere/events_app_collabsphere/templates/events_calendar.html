    if (isRecurringCheckboxEl) {
        isRecurringCheckboxEl.addEventListener('change', handleRecurringToggle);
    }
    if (frequencySelectEl) {
        frequencySelectEl.addEventListener('change', handleFrequencyChange);
    }

{% extends "base_dashboard.html" %}

{% load static %}

{% block title %}Events ‚Äì CollabSphere{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/sidebar.css' %}?v=1.0">
<link rel="stylesheet" href="{% static 'css/events_calendar.css' %}?v=1.0">
<link rel="stylesheet" href="{% static 'css/recurring_events.css' %}?v=1.0">
{% endblock %}

{% block extra_js %}
<script src="{% static 'js/sidebar.js' %}"></script>
<script src="{% static 'js/recurring_events.js' %}"></script>
{% endblock %}

{% block content %}
<div class="container-fluid calendar-container">
  <main class="calendar-main">
    
    <!-- Header Section -->
    <section class="calendar-header">
      <h1>Events Calendar</h1>
      <p>
        {% if team_name %}
          Managing schedule for <strong>{{ team_name }}</strong>
        {% else %}
          Manage your team's schedule and upcoming events
        {% endif %}
      </p>
      
      {% if not has_active_team %}
      <div class="alert alert-warning">
        <small>No active team selected. Please select a team to create and view events.</small>
      </div>
      {% endif %}
      
      <div class="calendar-controls">
        <div class="calendar-nav">
          <button class="btn-calendar" id="prevMonth">
            ‚Äπ Previous
          </button>
          <div class="current-month" id="currentMonth">Loading...</div>
          <button class="btn-calendar" id="nextMonth">
            Next ‚Ä∫
          </button>
        </div>
        <button class="btn-new" id="addEvent" {% if not has_active_team %}disabled title="Select a team to create events"{% endif %}>
          + New Event
        </button>
      </div>
    </section>

    <!-- Calendar Grid -->
    <section class="calendar-grid">
      <!-- Weekday Headers -->
      <div class="weekdays">
        <div class="weekday">Sunday</div>
        <div class="weekday">Monday</div>
        <div class="weekday">Tuesday</div>
        <div class="weekday">Wednesday</div>
        <div class="weekday">Thursday</div>
        <div class="weekday">Friday</div>
        <div class="weekday">Saturday</div>
      </div>
      
      <!-- Calendar Days -->
      <div class="calendar-days" id="calendarDays">
        <!-- Calendar will be populated by JavaScript -->
        <div class="loading-message">Loading calendar...</div>
      </div>
    </section>

    <!-- Upcoming Events Sidebar -->
    <section class="upcoming-events">
      <div class="card">
        <h3>Upcoming Events</h3>
        
        <div id="upcomingEventsList">
          {% for event in upcoming_events %}
          <div class="upcoming-item" data-event-id="{{ event.id }}">
            <div class="upcoming-date">
              <div class="upcoming-day">{{ event.day }}</div>
              <div class="upcoming-month">{{ event.month }}</div>
            </div>
            <div class="upcoming-details">
              <div class="upcoming-title">{{ event.title }}</div>
              <div class="upcoming-time">{{ event.time }}</div>
            </div>
            <div class="upcoming-actions">
              <span class="upcoming-type team">Team</span>
              <button type="button" class="btn-upcoming-delete" data-event-id="{{ event.id }}" aria-label="Remove event">
                <span class="btn-upcoming-delete-icon">&times;</span>
              </button>
            </div>
          </div>
          {% empty %}
          <div class="no-events">
            {% if has_active_team %}
              No upcoming events
            {% else %}
              Select a team to view events
            {% endif %}
          </div>
          {% endfor %}
        </div>
      </div>
    </section>

  </main>
</div>

<!-- Event Modal -->
<div class="modal fade" id="eventModal" tabindex="-1" aria-labelledby="eventModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="eventModalLabel">Create New Event</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="eventForm">
          {% csrf_token %}
          {% if team_name %}
          <div class="alert alert-info mb-3">
            <small>This event will be created for Team <strong>{{ team_name }}</strong></small>
          </div>
          {% endif %}
          
          <!-- Basic Event Information -->
          <div class="mb-3">
            <label for="eventTitle" class="form-label">Event Title *</label>
            <input type="text" class="form-control" id="eventTitle" name="title" required>
          </div>
          
          <div class="mb-3">
            <label for="eventDescription" class="form-label">Description</label>
            <textarea class="form-control" id="eventDescription" name="description" rows="3" placeholder="Optional event description..."></textarea>
          </div>
          
          <div class="row g-3 align-items-end">
            <div class="col-md-4">
              <label for="eventStartDate" class="form-label">Start Date *</label>
              <input type="date" class="form-control" id="eventStartDate" name="start_date" required>
            </div>
            <div class="col-md-4">
              <label class="form-label">Start Time *</label>
              <div class="d-flex gap-2 flex-wrap">
                <select class="form-select" id="eventStartHour" aria-label="Start hour" required>
                  {% for hour in hour_options %}
                  <option value="{{ hour }}">{{ hour }}</option>
                  {% endfor %}
                </select>
                <select class="form-select" id="eventStartMinute" aria-label="Start minutes" required>
                  {% for minute in minute_options %}
                  <option value="{{ minute }}">{{ minute }}</option>
                  {% endfor %}
                </select>
                <select class="form-select" id="eventStartMeridiem" aria-label="Start meridiem" required>
                  <option value="AM">AM</option>
                  <option value="PM">PM</option>
                </select>
              </div>
              <input type="hidden" id="eventStartTime" name="start_time" value="09:00">
            </div>
            <div class="col-md-4">
              <label class="form-label">End Time *</label>
              <div class="d-flex gap-2 flex-wrap">
                <select class="form-select" id="eventEndHour" aria-label="End hour" required>
                  {% for hour in hour_options %}
                  <option value="{{ hour }}">{{ hour }}</option>
                  {% endfor %}
                </select>
                <select class="form-select" id="eventEndMinute" aria-label="End minutes" required>
                  {% for minute in minute_options %}
                  <option value="{{ minute }}">{{ minute }}</option>
                  {% endfor %}
                </select>
                <select class="form-select" id="eventEndMeridiem" aria-label="End meridiem" required>
                  <option value="AM">AM</option>
                  <option value="PM">PM</option>
                </select>
              </div>
              <input type="hidden" id="eventEndTime" name="end_time" value="10:00">
            </div>
          </div>
          <input type="hidden" id="eventEndDate" name="end_date">
          
          <!-- ========================================== -->
          <!-- TASK 3.2.1: RECURRING EVENT OPTIONS START -->
          <!-- ========================================== -->
          
          <hr class="my-4">
          
          <div class="mb-3">
            <div class="form-check">
              <input type="checkbox" id="isRecurring" name="is_recurring" class="form-check-input">
              <label for="isRecurring" class="form-check-label fw-bold">
                üîÅ Recurring Event
              </label>
            </div>
          </div>

          <!-- Recurring Options Container (Hidden by default) -->
          <div id="recurringOptions" style="display: none;">
            
            <!-- Frequency Selection -->
            <div class="mb-3">
              <label for="frequency" class="form-label">Repeat Frequency</label>
              <select id="frequency" name="frequency" class="form-select">
                <option value="">Does not repeat</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="monthly">Monthly</option>
                <option value="yearly">Yearly</option>
              </select>
            </div>

            <!-- Weekly Day Selector (Shows only for weekly frequency) -->
            <div class="mb-3" id="weeklyOptions" style="display: none;">
              <label class="form-label">Repeat on these days</label>
              <div class="btn-group d-flex" role="group" aria-label="Days of week">
                <input type="checkbox" class="btn-check" id="sun" name="days[]" value="0" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="sun">Sun</label>
                
                <input type="checkbox" class="btn-check" id="mon" name="days[]" value="1" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="mon">Mon</label>
                
                <input type="checkbox" class="btn-check" id="tue" name="days[]" value="2" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="tue">Tue</label>
                
                <input type="checkbox" class="btn-check" id="wed" name="days[]" value="3" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="wed">Wed</label>
                
                <input type="checkbox" class="btn-check" id="thu" name="days[]" value="4" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="thu">Thu</label>
                
                <input type="checkbox" class="btn-check" id="fri" name="days[]" value="5" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="fri">Fri</label>
                
                <input type="checkbox" class="btn-check" id="sat" name="days[]" value="6" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="sat">Sat</label>
              </div>
            </div>

            <!-- End Options -->
            <div class="mb-3">
              <label for="endsOn" class="form-label">Ends</label>
              <select id="endsOn" name="ends_on" class="form-select">
                <option value="never">Never</option>
                <option value="on">On a specific date</option>
                <option value="after">After a number of occurrences</option>
              </select>
            </div>

            <!-- End Date Field (Shows when "On date" is selected) -->
            <div class="mb-3" id="endDateField" style="display: none;">
              <label for="recurrenceEndDate" class="form-label">End Date</label>
              <input type="date" id="recurrenceEndDate" name="recurrence_end_date" class="form-control">
            </div>

            <!-- Occurrences Field (Shows when "After" is selected) -->
            <div class="mb-3" id="occurrencesField" style="display: none;">
              <label for="occurrences" class="form-label">Number of Occurrences</label>
              <input type="number" id="occurrences" name="occurrences" class="form-control" min="1" value="10" placeholder="e.g., 10">
              <div class="form-text">How many times should this event repeat?</div>
            </div>

            <!-- Recurrence Summary -->
            <div class="alert alert-info" id="recurrenceSummary" style="display: none;">
              <strong>üìÖ Summary:</strong> <span id="summaryText"></span>
            </div>

          </div>
          
          <!-- ======================================== -->
          <!-- TASK 3.2.1: RECURRING EVENT OPTIONS END -->
          <!-- ======================================== -->
          
          <div class="form-text mt-3">* Required fields. Start and end times are captured for the same calendar day.</div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="saveEvent">
          <span class="spinner-border spinner-border-sm d-none" role="status"></span>
          Save Event
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Day Action Modal -->
<div class="modal fade" id="dayActionModal" tabindex="-1" aria-labelledby="dayActionLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="dayActionLabel">Create an event for this day?</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-1">Would you like to schedule a new event on this date?</p>
        <div id="dayActionDate" class="text-muted small"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Not Now</button>
        <button type="button" class="btn btn-primary" id="confirmDayCreate">Create Event</button>
      </div>
    </div>
  </div>
</div>

<!-- Day Events Modal -->
<div class="modal fade" id="dayEventsModal" tabindex="-1" aria-labelledby="dayEventsLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="dayEventsLabel">Events on Selected Day</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="dayEventsDate" class="text-muted small mb-3"></div>
        <div id="dayEventsContainer" class="day-events-list"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Event Details Modal -->
<div class="modal fade" id="eventDetailsModal" tabindex="-1" aria-labelledby="eventDetailsLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="eventDetailsLabel">Event Details</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <h4 id="eventDetailsTitle" class="mb-2"></h4>
        <div id="eventDetailsTime" class="text-muted mb-3"></div>
        <p id="eventDetailsDescription" class="mb-0"></p>
        <div class="event-meta mt-4">
          <div class="d-flex flex-wrap gap-3 align-items-center justify-content-between mb-3">
            <div class="event-host-block">
              <span class="text-muted text-uppercase small">Hosted by</span>
              <div id="eventHostName" class="fw-semibold text-dark">‚Äî</div>
            </div>  
            <button type="button" class="btn btn-primary btn-participation" id="eventParticipationButton" disabled>
              Join Event
            </button>
          </div>
          <div class="event-participants-wrapper">
            <div class="d-flex align-items-center justify-content-between mb-2">
              <span class="fw-semibold">Participants</span>
              <span id="eventParticipantsCount" class="badge rounded-pill bg-light text-dark">0</span>
            </div>
            <div id="eventParticipantsList" class="participant-list text-muted small">
              No participants yet.
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade" id="confirmDeleteModal" tabindex="-1" aria-labelledby="confirmDeleteLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="confirmDeleteLabel">Remove Event</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="confirmDeleteMessage">
        Are you sure you want to remove this event?
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-danger" id="confirmDeleteButton">Yes, Remove</button>
      </div>
    </div>
  </div>
</div>

<script>
// Global variables
const initialYear = Number("{{ initial_year|default_if_none:'0' }}");
const initialMonth = Number("{{ initial_month|default_if_none:'1' }}");

let currentDate = new Date(initialYear || new Date().getFullYear(), (initialMonth || (new Date().getMonth() + 1)) - 1, 1);

let currentEvents = JSON.parse("{{ events_json|escapejs }}");
let selectedDateKey = null;
const hasActiveTeam = "{{ has_active_team|yesno:'true,false' }}" === 'true';
let pendingDayDateKey = null;

let pendingDeleteEventId = null;
let deleteCallback = null;
let activeEventDetails = null;
const dayActionModal = document.getElementById('dayActionModal');
const dayEventsModal = document.getElementById('dayEventsModal');
const eventDetailsModal = document.getElementById('eventDetailsModal');
const confirmDeleteModal = document.getElementById('confirmDeleteModal');
const eventHostNameEl = document.getElementById('eventHostName');
const eventParticipantsList = document.getElementById('eventParticipantsList');
const eventParticipantsCount = document.getElementById('eventParticipantsCount');
const eventParticipationButton = document.getElementById('eventParticipationButton');
const upcomingEventsListEl = document.getElementById('upcomingEventsList');
const MAX_UPCOMING_ITEMS = 5;
const modalInstances = {
    dayAction: null,
    dayEvents: null,
    eventDetails: null,
    deleteConfirm: null
};
const eventUrls = {
    create: "{% url 'create_event' %}",
    getMonth: "{% url 'get_events' %}",
    detailBase: "{% url 'get_event' 0 %}".replace(/0\/$/, ''),
    deleteBase: "{% url 'delete_event' 0 %}".replace(/0\/$/, ''),
    join: "{% url 'join_event' 0 %}".replace(/0\/$/, ''),
    leave: "{% url 'leave_event' 0 %}".replace(/0\/$/, '')
};
const recurrenceOptionsContainer = document.getElementById('recurringOptions');
const recurrenceSummaryEl = document.getElementById('recurrenceSummary');
const recurrenceSummaryTextEl = document.getElementById('summaryText');
const frequencySelectEl = document.getElementById('frequency');
const weeklyOptionsEl = document.getElementById('weeklyOptions');
const endsOnSelectEl = document.getElementById('endsOn');
const isRecurringCheckboxEl = document.getElementById('isRecurring');
const startHourSelectEl = document.getElementById('eventStartHour');
const startMinuteSelectEl = document.getElementById('eventStartMinute');
const startMeridiemSelectEl = document.getElementById('eventStartMeridiem');
const endHourSelectEl = document.getElementById('eventEndHour');
const endMinuteSelectEl = document.getElementById('eventEndMinute');
const endMeridiemSelectEl = document.getElementById('eventEndMeridiem');
const startTimeHiddenInput = document.getElementById('eventStartTime');
const endTimeHiddenInput = document.getElementById('eventEndTime');

const CALENDAR_VIEW_STORAGE_KEY = 'collabsphere.calendar.view';

function loadStoredCalendarView() {
    try {
        const raw = localStorage.getItem(CALENDAR_VIEW_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (Number.isFinite(parsed?.year) && Number.isFinite(parsed?.month)) {
            return parsed;
        }
    } catch (err) {
        console.warn('Unable to read stored calendar view:', err);
    }
    return null;
}

function persistCalendarView(dateObj) {
    try {
        if (!(dateObj instanceof Date)) return;
        const payload = {
            year: dateObj.getFullYear(),
            month: dateObj.getMonth() + 1,
        };
        localStorage.setItem(CALENDAR_VIEW_STORAGE_KEY, JSON.stringify(payload));
    } catch (err) {
        console.warn('Unable to persist calendar view:', err);
    }
}

function initModalInstances() {
    if (typeof bootstrap === 'undefined' || !bootstrap.Modal) {
        console.warn('Bootstrap JavaScript is required for modals.');
        return;
    }
    modalInstances.dayAction = dayActionModal ? bootstrap.Modal.getOrCreateInstance(dayActionModal) : null;
    modalInstances.dayEvents = dayEventsModal ? bootstrap.Modal.getOrCreateInstance(dayEventsModal) : null;
    modalInstances.eventDetails = eventDetailsModal ? bootstrap.Modal.getOrCreateInstance(eventDetailsModal) : null;
    modalInstances.deleteConfirm = confirmDeleteModal ? bootstrap.Modal.getOrCreateInstance(confirmDeleteModal) : null;
}

function formatDateKey(year, monthIndex, day) {
    const month = String(monthIndex + 1).padStart(2, '0');
    const dayStr = String(day).padStart(2, '0');
    return `${year}-${month}-${dayStr}`;
}

function dayKeyToDate(dateKey) {
    const [year, month, day] = dateKey.split('-').map(Number);
    return new Date(year, month - 1, day);
}

function formatLocalDateKey(dateObj) {
    if (!(dateObj instanceof Date)) return '';
    return formatDateKey(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
}

function isPastDate(dateKey) {
    if (!dateKey) return false;
    const todayKey = formatLocalDateKey(new Date());
    return dateKey < todayKey;
}

function setSelectedDate(dateKey) {
    selectedDateKey = dateKey;
    highlightSelectedDate();
}

function highlightSelectedDate() {
    document.querySelectorAll('.calendar-day.selected').forEach(el => el.classList.remove('selected'));
    if (!selectedDateKey) return;
    const selectedEl = document.querySelector(`.calendar-day[data-date-key="${selectedDateKey}"]`);
    if (selectedEl) {
        selectedEl.classList.add('selected');
    }
}

function getDefaultEventDateKey() {
    if (selectedDateKey && !isPastDate(selectedDateKey)) {
        return selectedDateKey;
    }
    return formatLocalDateKey(new Date());
}

function applyDateToEventForm(dateKey) {
    const startInput = document.getElementById('eventStartDate');
    const endInput = document.getElementById('eventEndDate');
    if (startInput) {
        startInput.value = dateKey;
        startInput.min = formatLocalDateKey(new Date());
    }
    if (endInput) {
        endInput.value = dateKey;
    }
}

function resetEventTimeFields(startTime = '09:00', endTime = '10:00') {
    setTimeSelectorsFrom24Hour(startTime, startHourSelectEl, startMinuteSelectEl, startMeridiemSelectEl);
    setTimeSelectorsFrom24Hour(endTime, endHourSelectEl, endMinuteSelectEl, endMeridiemSelectEl);
    syncAllHiddenTimeFields();
}

function setTimeSelectorsFrom24Hour(timeValue = '09:00', hourSelect, minuteSelect, meridiemSelect) {
    if (!hourSelect || !minuteSelect || !meridiemSelect) return;
    const [rawHour = '09', rawMinute = '00'] = (timeValue || '09:00').split(':');
    let hour24 = parseInt(rawHour, 10);
    if (Number.isNaN(hour24)) {
        hour24 = 9;
    }
    const minuteValue = rawMinute.padStart(2, '0');
    const isPM = hour24 >= 12;
    let hour12 = hour24 % 12;
    if (hour12 === 0) hour12 = 12;
    setSelectValue(hourSelect, String(hour12));
    setSelectValue(minuteSelect, minuteValue);
    meridiemSelect.value = isPM ? 'PM' : 'AM';
}

function setSelectValue(selectEl, value) {
    if (!selectEl || typeof value === 'undefined' || value === null) return;
    const exists = Array.from(selectEl.options || []).some(opt => opt.value === value);
    if (!exists) {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = value;
        selectEl.appendChild(option);
    }
    selectEl.value = value;
}

function convertTo24Hour(hour, minute, meridiem) {
    let parsedHour = parseInt(hour, 10);
    const sanitizedMinute = String(minute || '00').padStart(2, '0');
    if (Number.isNaN(parsedHour)) {
        parsedHour = 9;
    }
    if ((meridiem || 'AM').toUpperCase() === 'PM' && parsedHour !== 12) {
        parsedHour += 12;
    }
    if ((meridiem || 'AM').toUpperCase() === 'AM' && parsedHour === 12) {
        parsedHour = 0;
    }
    return `${String(parsedHour).padStart(2, '0')}:${sanitizedMinute}`;
}

function syncHiddenTimeField(hourSelect, minuteSelect, meridiemSelect, hiddenInput) {
    if (!hourSelect || !minuteSelect || !meridiemSelect || !hiddenInput) return;
    hiddenInput.value = convertTo24Hour(hourSelect.value, minuteSelect.value, meridiemSelect.value);
}

function syncStartTimeHidden() {
    syncHiddenTimeField(startHourSelectEl, startMinuteSelectEl, startMeridiemSelectEl, startTimeHiddenInput);
}

function syncEndTimeHidden() {
    syncHiddenTimeField(endHourSelectEl, endMinuteSelectEl, endMeridiemSelectEl, endTimeHiddenInput);
}

function syncAllHiddenTimeFields() {
    syncStartTimeHidden();
    syncEndTimeHidden();
}

function formatTimeTo12Hour(timeValue) {
    if (!timeValue) return '';
    const [hourStr, minuteStr = '00'] = timeValue.split(':');
    let hour = parseInt(hourStr, 10);
    if (Number.isNaN(hour)) {
        return timeValue || '';
    }
    const ampm = hour >= 12 ? 'PM' : 'AM';
    hour = hour % 12 || 12;
    return `${hour}:${minuteStr.padStart(2, '0')} ${ampm}`;
}

function handleDaySelection(dateKey) {
    if (!hasActiveTeam) {
        showWarning('Select a team before creating events.');
        return;
    }
    setSelectedDate(dateKey);
    const eventsForDay = getEventsForDate(dateKey);
    const pastDate = isPastDate(dateKey);
    if (eventsForDay.length > 0) {
        showDayEventsModal(dateKey, eventsForDay);
        return;
    }
    if (pastDate) {
        showWarning('Events cannot be created before today.');
        return;
    }
    showDayCreatePrompt(dateKey);
}

function getEventsForDate(dateKey) {
    if (!Array.isArray(currentEvents)) return [];
    return currentEvents.filter(evt => normalizeDateKey(evt.start) === dateKey);
}

function normalizeDateKey(dateStr) {
    if (!dateStr) return '';
    if (dateStr.length === 10) return dateStr;
    return dateStr.split('T')[0];
}

function showDayCreatePrompt(dateKey) {
    pendingDayDateKey = dateKey;
    const dateDisplay = document.getElementById('dayActionDate');
    if (dateDisplay) {
        dateDisplay.textContent = dayKeyToDate(dateKey).toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
    }
    if (modalInstances.dayAction) {
        modalInstances.dayAction.show();
    }
}

function handleConfirmedDayCreate() {
    if (!pendingDayDateKey) return;
    if (isPastDate(pendingDayDateKey)) {
        showWarning('Events cannot be created before today.');
        pendingDayDateKey = null;
        if (modalInstances.dayAction) {
            modalInstances.dayAction.hide();
        }
        return;
    }
    const dateObj = dayKeyToDate(pendingDayDateKey);
    openEventModalForDate(dateObj);
    pendingDayDateKey = null;
    if (modalInstances.dayAction) {
        modalInstances.dayAction.hide();
    }
}

function openEventModalForDate(dateObj) {
    if (!dateObj) return;
    const dateKey = formatLocalDateKey(dateObj);
    if (isPastDate(dateKey)) {
        showWarning('Events cannot be created before today.');
        return;
    }
    setSelectedDate(dateKey);
    applyDateToEventForm(dateKey);
    resetEventTimeFields();
    const modalElement = document.getElementById('eventModal');
    if (modalElement) {
        const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
        modal.show();
    }
}

function showDayEventsModal(dateKey, events) {
    const container = document.getElementById('dayEventsContainer');
    const dateLabel = document.getElementById('dayEventsDate');
    if (dateLabel) {
        dateLabel.textContent = dayKeyToDate(dateKey).toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
    }
    if (container) {
        container.innerHTML = '';
        events.sort((a, b) => (a.start_time || '').localeCompare(b.start_time || ''));
        events.forEach(event => {
            const card = document.createElement('div');
            card.className = 'day-event-card';
            card.innerHTML = `
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h6 class="mb-1">${event.title}</h6>
                            <div class="text-muted small">${event.start_time || ''} - ${event.end_time || ''}</div>
                        </div>
                        <button class="btn btn-link btn-sm p-0" data-event-id="${event.id || ''}">View</button>
                    </div>
                    <p class="mb-0 small text-muted mt-2">${event.description || 'No description provided.'}</p>
                </div>
            `;
            const viewBtn = card.querySelector('button[data-event-id]');
            if (viewBtn) {
                viewBtn.addEventListener('click', () => {
                    if (event.id) {
                        openEventDetailsById(event.id);
                    }
                });
            }
            container.appendChild(card);
        });
    }
    if (modalInstances.dayEvents) {
        modalInstances.dayEvents.show();
    }
}

async function openEventDetailsById(eventId) {
    if (!eventId) return;
    try {
        const response = await fetch(`${eventUrls.detailBase}${eventId}`);

        const result = await response.json();
        if (result.success && result.event) {
            populateEventDetailsModal(result.event);
        } else {
            showError(result.error || 'Unable to load event details');
        }
    } catch (error) {
        console.error('Error fetching event details:', error);
        showError('Unable to load event details');
    }
}

function populateEventDetailsModal(event) {
    const titleEl = document.getElementById('eventDetailsTitle');
    const timeEl = document.getElementById('eventDetailsTime');
    const descEl = document.getElementById('eventDetailsDescription');
    if (titleEl) titleEl.textContent = event.title || 'Untitled Event';
    if (timeEl) {
        timeEl.textContent = `${event.start_date || ''} ${event.start_time || ''} - ${event.end_date || ''} ${event.end_time || ''}`.trim();
    }
    if (descEl) descEl.textContent = event.description || 'No description provided.';
    const normalized = { ...event, id: event.id || event.event_id };
    normalized.host_name = event.host_name || event.host_username || 'Unknown Host';
    normalized.host_username = event.host_username || null;
    normalized.host_id = event.host_id || event.user_id || null;
    activeEventDetails = normalized;
    setHostName(normalized.host_name);
    renderParticipantsList(normalized.participants);
    updateParticipationButtonState(normalized);
    if (modalInstances.eventDetails) {
        modalInstances.eventDetails.show();
    }
}

function setHostName(name) {
    if (eventHostNameEl) {
        eventHostNameEl.textContent = name || 'Unknown Host';
    }
}

function renderParticipantsList(participants) {
    if (!eventParticipantsList || !eventParticipantsCount) return;
    const list = Array.isArray(participants) ? participants : [];
    eventParticipantsCount.textContent = list.length;
    if (!list.length) {
        eventParticipantsList.innerHTML = '<span class="text-muted">No participants yet.</span>';
        return;
    }
    const markup = list.map(participant => {
        const safeName = participant?.name || 'Unknown member';
        const hostBadge = participant?.is_host ? '<span class="participant-host-pill">Host</span>' : '';
        return `
            <div class="participant-item">
                <span class="participant-name">${safeName}</span>
                ${hostBadge}
            </div>
        `;
    }).join('');
    eventParticipantsList.innerHTML = markup;
}

function updateParticipationButtonState(detail) {
    if (!eventParticipationButton) return;
    const isHost = detail?.is_host;
    const hasJoined = detail?.has_joined;
    eventParticipationButton.classList.remove('btn-danger', 'btn-primary', 'btn-outline-secondary');
    const eventId = detail?.id || detail?.event_id;
    if (eventId) {
        eventParticipationButton.dataset.eventId = eventId;
    }
    if (isHost) {
        eventParticipationButton.textContent = 'You are the host';
        eventParticipationButton.classList.add('btn-outline-secondary');
        eventParticipationButton.dataset.action = '';
        eventParticipationButton.disabled = true;
        return;
    }
    eventParticipationButton.disabled = false;
    if (hasJoined) {
        eventParticipationButton.textContent = 'Leave Event';
        eventParticipationButton.classList.add('btn-danger');
        eventParticipationButton.dataset.action = 'leave';
    } else {
        eventParticipationButton.textContent = 'Join Event';
        eventParticipationButton.classList.add('btn-primary');
        eventParticipationButton.dataset.action = 'join';
    }
}

async function handleParticipationAction() {
    if (!eventParticipationButton || !activeEventDetails) return;
    const action = eventParticipationButton.dataset.action;
    const eventId = activeEventDetails.id || activeEventDetails.event_id;
    if (!action || !eventId) {
        return;
    }

    const csrfToken = getCSRFToken();
    const endpointBase = action === 'join' ? eventUrls.join : eventUrls.leave;
    const url = `${endpointBase}${eventId}/`;
    const originalText = eventParticipationButton.textContent;
    eventParticipationButton.disabled = true;
    eventParticipationButton.textContent = action === 'join' ? 'Joining‚Ä¶' : 'Leaving‚Ä¶';

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken || ''
            },
            body: JSON.stringify({})
        });
        const result = await response.json();
        if (!response.ok || !result.success) {
            throw new Error(result.error || 'Unable to update participation');
        }
        const payload = result.participant_data;
        if (payload) {
            activeEventDetails.participants = payload.participants || [];
            activeEventDetails.participant_count = payload.participant_count;
            activeEventDetails.is_host = payload.is_host;
            activeEventDetails.has_joined = payload.has_joined;
            activeEventDetails.host_name = payload.host_name || payload.host_username;
            activeEventDetails.host_username = payload.host_username || null;
            setHostName(activeEventDetails.host_name);
            renderParticipantsList(activeEventDetails.participants);
        }
    } catch (error) {
        console.error('Participation error:', error);
        showError(error.message || 'Unable to update participation');
    } finally {
        updateParticipationButtonState(activeEventDetails);
        if (!activeEventDetails?.is_host && eventParticipationButton) {
            eventParticipationButton.disabled = false;
        }
        if (!activeEventDetails) {
            eventParticipationButton.textContent = originalText;
        }
    }
}

function addNewEventToCalendarCache(formData, eventId) {
    if (!Array.isArray(currentEvents)) {
        currentEvents = [];
    }

    const startDate = formData.get('start_date');
    const endTime = formData.get('end_time');
    const startTime = formData.get('start_time');
    const newEvent = {
        id: eventId,
        title: formData.get('title'),
        description: formData.get('description') || '',
        start: startDate,
        start_time: formatTimeTo12Hour(startTime),
        end_time: formatTimeTo12Hour(endTime),
        is_recurring: formData.get('is_recurring') === 'on'
    };
    currentEvents.push(newEvent);
    renderCalendar();
    return newEvent;
}

function addNewEventToUpcomingList(formData, eventId) {
    if (!upcomingEventsListEl) {
        return;
    }

    const startDateStr = formData.get('start_date');
    const startTime = formData.get('start_time');
    const endTime = formData.get('end_time');
    const title = (formData.get('title') || 'Untitled Event').trim() || 'Untitled Event';
    if (!startDateStr || !startTime) {
        return;
    }

    const startDateObj = buildDateFromForm(startDateStr, startTime);
    if (!startDateObj) {
        return;
    }

    const dayLabel = startDateObj.getDate();
    const monthLabel = startDateObj.toLocaleString(undefined, { month: 'short' });
    const startLabel = formatTimeTo12Hour(startTime);
    const endLabel = endTime ? formatTimeTo12Hour(endTime) : null;
    const timeLabel = endLabel ? `${startLabel} - ${endLabel}` : startLabel;

    const newItem = createUpcomingItemElement({
        eventId,
        day: dayLabel,
        monthLabel,
        title,
        timeLabel
    });

    const emptyState = upcomingEventsListEl.querySelector('.no-events');
    if (emptyState) {
        emptyState.remove();
    }

    const firstExistingItem = upcomingEventsListEl.querySelector('.upcoming-item');
    if (firstExistingItem) {
        upcomingEventsListEl.insertBefore(newItem, firstExistingItem);
    } else {
        upcomingEventsListEl.appendChild(newItem);
    }

    enforceUpcomingListLimit();
}

function buildDateFromForm(dateStr, timeStr = '00:00') {
    if (!dateStr) {
        return null;
    }
    const [yearStr, monthStr, dayStr] = dateStr.split('-') || [];
    const [hourStr = '00', minuteStr = '00'] = (timeStr || '00:00').split(':');
    const year = parseInt(yearStr, 10);
    const month = parseInt(monthStr, 10);
    const day = parseInt(dayStr, 10);
    const hour = parseInt(hourStr, 10);
    const minute = parseInt(minuteStr, 10);
    if ([year, month, day, hour, minute].some(val => Number.isNaN(val))) {
        return null;
    }
    return new Date(year, month - 1, day, hour, minute);
}

function createUpcomingItemElement({ eventId, day, monthLabel, title, timeLabel }) {
    const wrapper = document.createElement('div');
    wrapper.className = 'upcoming-item';
    if (eventId) {
        wrapper.dataset.eventId = eventId;
    }
    wrapper.innerHTML = `
        <div class="upcoming-date">
            <div class="upcoming-day">${day}</div>
            <div class="upcoming-month">${monthLabel}</div>
        </div>
        <div class="upcoming-details">
            <div class="upcoming-title">${title}</div>
            <div class="upcoming-time">${timeLabel}</div>
        </div>
        <div class="upcoming-actions">
            <span class="upcoming-type team">Team</span>
            <button type="button" class="btn-upcoming-delete" data-event-id="${eventId || ''}" aria-label="Remove event">
                <span class="btn-upcoming-delete-icon">&times;</span>
            </button>
        </div>
    `;
    return wrapper;
}

function enforceUpcomingListLimit() {
    if (!upcomingEventsListEl || !Number.isFinite(MAX_UPCOMING_ITEMS) || MAX_UPCOMING_ITEMS <= 0) {
        return;
    }
    const items = Array.from(upcomingEventsListEl.querySelectorAll('.upcoming-item'));
    if (items.length <= MAX_UPCOMING_ITEMS) {
        return;
    }
    items.slice(MAX_UPCOMING_ITEMS).forEach(item => item.remove());
}

function removeEventFromCalendarCache(eventId) {
    if (!Array.isArray(currentEvents)) {
        return;
    }
    const originalLength = currentEvents.length;
    currentEvents = currentEvents.filter(evt => String(evt.id) !== String(eventId));
}

function handleUpcomingListClick(event) {
    const deleteBtn = event.target.closest('.btn-upcoming-delete');
    const item = event.target.closest('.upcoming-item');
    if (deleteBtn) {
        const eventId = deleteBtn.dataset.eventId;
        if (eventId) {
            requestDeleteConfirmation(eventId, () => {
                if (item) {
                    item.remove();
                }
            });
        }
    } else if (item && item.dataset.eventId) {
        openEventDetailsById(item.dataset.eventId);
    }
}

function requestDeleteConfirmation(eventId, callback) {
    pendingDeleteEventId = eventId;
    deleteCallback = callback;
    if (modalInstances.deleteConfirm) {
        modalInstances.deleteConfirm.show();
    }
}

async function finalizeDeleteRequest() {
    if (!pendingDeleteEventId) return;
    const eventId = pendingDeleteEventId;
    try {
        await deleteEventById(eventId);
        if (deleteCallback) {
            deleteCallback();
        }
        deleteCallback = null;
        pendingDeleteEventId = null;
        if (modalInstances.deleteConfirm) {
            modalInstances.deleteConfirm.hide();
        }
    } catch (error) {
        console.error('Delete error:', error);
        showError('Failed to delete event.');
    }
}

async function deleteEventById(eventId) {
    const csrfToken = getCSRFToken();
    const response = await fetch(`${eventUrls.deleteBase}${eventId}/`, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': csrfToken || ''
        }
    });
    const result = await response.json();
    if (!result.success) {
        throw new Error(result.error || 'Delete failed');
    }
    removeEventFromCalendarCache(eventId);
    loadEventsForMonth();
    showToast('Event removed', 'success');
}

function showWarning(message) {
    showToast(message, 'warning');
}

function showError(message) {
    showToast(message, 'danger');
}

function showInfo(message) {
    showToast(message, 'info');
}

document.addEventListener('DOMContentLoaded', function() {
    console.log('üü¢ Calendar DOM loaded');
    const storedView = loadStoredCalendarView();
    if (storedView) {
        currentDate = new Date(storedView.year, storedView.month - 1, 1);
    } else if (Number.isFinite(initialYear) && Number.isFinite(initialMonth) && initialYear > 0 && initialMonth > 0) {
        currentDate = new Date(initialYear, initialMonth - 1, 1);
    }

    initializeCalendar();
    initModalInstances();
    
    // Event listeners - check if elements exist first
    const prevMonthBtn = document.getElementById('prevMonth');
    const nextMonthBtn = document.getElementById('nextMonth');
    const addEventBtn = document.getElementById('addEvent');
    const saveEventBtn = document.getElementById('saveEvent');
    const startDateInput = document.getElementById('eventStartDate');
    const endDateInput = document.getElementById('eventEndDate');
    const confirmDayCreateBtn = document.getElementById('confirmDayCreate');
    const confirmDeleteBtn = document.getElementById('confirmDeleteButton');
    const upcomingList = document.getElementById('upcomingEventsList');
    
    if (prevMonthBtn) prevMonthBtn.addEventListener('click', previousMonth);
    if (nextMonthBtn) nextMonthBtn.addEventListener('click', nextMonth);
    if (addEventBtn) addEventBtn.addEventListener('click', showEventModal);
    if (saveEventBtn) saveEventBtn.addEventListener('click', saveEvent);
    if (startDateInput && endDateInput) {
        startDateInput.addEventListener('change', () => {
            if (startDateInput.value) {
                endDateInput.value = startDateInput.value;
            }
            updateRecurrenceSummary();
        });
    }
    if (confirmDayCreateBtn) {
        confirmDayCreateBtn.addEventListener('click', handleConfirmedDayCreate);
    }
    if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', finalizeDeleteRequest);
    }
    if (upcomingList) {
        upcomingList.addEventListener('click', handleUpcomingListClick);
    }
    if (eventParticipationButton) {
        eventParticipationButton.addEventListener('click', handleParticipationAction);
    }
    [startHourSelectEl, startMinuteSelectEl, startMeridiemSelectEl].forEach(el => {
        if (el) el.addEventListener('change', syncStartTimeHidden);
    });
    [endHourSelectEl, endMinuteSelectEl, endMeridiemSelectEl].forEach(el => {
        if (el) el.addEventListener('change', syncEndTimeHidden);
    });
    syncAllHiddenTimeFields();
    
    // Always refresh the current month from the backend so the UI
    // stays in sync with live data (even if the initial payload was empty).
    loadEventsForMonth();
});

function getCSRFToken() {
    const name = 'csrftoken';
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.startsWith(name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    if (cookieValue && cookieValue.trim().length > 0) {
        return cookieValue.trim();
    }

    const formToken = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (formToken && formToken.value) {
        return formToken.value.trim();
    }

    const metaToken = document.querySelector('meta[name="csrf-token"], meta[name="csrfmiddlewaretoken"]');
    if (metaToken && metaToken.getAttribute('content')) {
        return metaToken.getAttribute('content').trim();
    }

    return null;
}

function initializeCalendar() {
    console.log('üü¢ Initializing calendar');
    updateCalendarHeader();
    renderCalendar();
}

function updateCalendarHeader() {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"];
    const currentMonthElement = document.getElementById('currentMonth');
    if (currentMonthElement) {
        currentMonthElement.textContent = 
            `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
    }
    persistCalendarView(currentDate);
}

function renderCalendar() {
    const calendarDays = document.getElementById('calendarDays');
    if (!calendarDays) {
        console.error('‚ùå Calendar days container not found');
        return;
    }
    
    calendarDays.innerHTML = '';
    
    const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
    const startingDayOfWeek = firstDay.getDay();
    const totalDays = lastDay.getDate();
    
    // Previous month days
    const prevMonthDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 0);
    const prevMonthLastDay = prevMonthDate.getDate();
    for (let i = startingDayOfWeek - 1; i >= 0; i--) {
        const dayNum = prevMonthLastDay - i;
        const dateKey = formatDateKey(prevMonthDate.getFullYear(), prevMonthDate.getMonth(), dayNum);
        const dayElement = createDayElement(dayNum, true, false, dateKey);
        calendarDays.appendChild(dayElement);
    }

    // Current month days
    const today = new Date();
    for (let day = 1; day <= totalDays; day++) {
        const isToday = today.getDate() === day && 
                       today.getMonth() === currentDate.getMonth() && 
                       today.getFullYear() === currentDate.getFullYear();
        const dateKey = formatDateKey(currentDate.getFullYear(), currentDate.getMonth(), day);
        const dayElement = createDayElement(day, false, isToday, dateKey);
        calendarDays.appendChild(dayElement);
    }
    
    // Add events to days
    addEventsToCalendar();
    highlightSelectedDate();
}

function createDayElement(dayNumber, isOtherMonth, isToday = false, dateKey = null) {
    const dayElement = document.createElement('div');
    dayElement.className = 'calendar-day';
    if (isOtherMonth) dayElement.classList.add('other-month');
    if (isToday) dayElement.classList.add('today');
    const dateAttr = dateKey ? `data-date="${dateKey}"` : '';
    if (dateKey) {
        dayElement.dataset.dateKey = dateKey;
        dayElement.setAttribute('data-date-key', dateKey);
    }

    dayElement.innerHTML = `
        <div class="day-number">${dayNumber}</div>
        <div class="events-container" data-day="${dayNumber}" ${dateAttr}></div>
    `;
    
    if (!isOtherMonth) {
        dayElement.addEventListener('click', (event) => {
            const eventItem = event.target.closest('.event-item');
            if (eventItem && eventItem.dataset.eventId) {
                event.stopPropagation();
                openEventDetailsById(eventItem.dataset.eventId);
                return;
            }
            if (dayElement.dataset.dateKey) {
                handleDaySelection(dayElement.dataset.dateKey);
            }
        });
    }
    
    return dayElement;
}

function addEventsToCalendar() {
    if (!currentEvents || !Array.isArray(currentEvents)) {
        console.log('No events to display');
        return;
    }

    currentEvents.forEach(event => {
        const rawDate = normalizeDateKey(event.start);
        if (!rawDate) {
            return;
        }

        const parts = rawDate.split('-');
        if (parts.length !== 3) {
            return;
        }

        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10); // 1-based
        const day = parseInt(parts[2], 10);

        if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) {
            return;
        }

        if (year === currentDate.getFullYear() && month === (currentDate.getMonth() + 1)) {
            const dayElement = document.querySelector(`.events-container[data-date="${rawDate}"]`);
            if (dayElement) {
                const eventElement = document.createElement('div');
                eventElement.className = 'event-item team-meeting';
                if (event.id) {
                    eventElement.dataset.eventId = event.id;
                }

                const recurringIcon = event.is_recurring ? 'üîÅ ' : '';

                eventElement.innerHTML = `
                    <span class="event-time">${event.start_time}</span>
                    <span class="event-title">${recurringIcon}${event.title}</span>
                `;
                eventElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (event.id) {
                        openEventDetailsById(event.id);
                    }
                });
                dayElement.appendChild(eventElement);
            }
        }
    });

    const hasEvents = currentEvents.length > 0;
    const hasActiveTeam = '{{ has_active_team|yesno:"true,false" }}' === 'true';

    if (!hasEvents && !hasActiveTeam) {
        const calendarDays = document.getElementById('calendarDays');
        const message = document.createElement('div');
        message.className = 'no-team-message';
        message.style.gridColumn = '1 / -1';
        message.style.textAlign = 'center';
        message.style.padding = '2rem';
        message.style.color = '#6c757d';
        message.innerHTML = `
            <p>No active team selected. Please select a team to view and create events.</p>
        `;
        calendarDays.appendChild(message);
    }
}

function showEventModalForDay(day) {
    const startDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
    openEventModalForDate(startDate);
}

function showEventModal() {
    console.log('üü¢ Showing event modal');

    // Clear form and set default values
    const eventTitle = document.getElementById('eventTitle');
    const eventDescription = document.getElementById('eventDescription');
    const eventStartDate = document.getElementById('eventStartDate');
    const eventStartTime = document.getElementById('eventStartTime');
    const eventEndDate = document.getElementById('eventEndDate');
    const eventEndTime = document.getElementById('eventEndTime');
    
    if (eventTitle) eventTitle.value = '';
    if (eventDescription) eventDescription.value = '';
    
    const defaultDateKey = getDefaultEventDateKey();
    setSelectedDate(defaultDateKey);
    applyDateToEventForm(defaultDateKey);
    resetEventTimeFields();

    // Reset recurring options
    if (isRecurringCheckboxEl) {
        isRecurringCheckboxEl.checked = false;
    }
    toggleRecurringOptions(false);
    updateRecurrenceSummary();
    resetEventTimeFields();
    
    const modalElement = document.getElementById('eventModal');
    if (modalElement) {
        const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
        modal.show();
    }
}

async function saveEvent() {
    console.log('üü¢ Saving event...');
    
    const saveBtn = document.getElementById('saveEvent');
    if (!saveBtn) {
        console.error('‚ùå Save button not found');
        return;
    }
    
    // Show loading state
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Saving...';
    
    const eventTitle = document.getElementById('eventTitle');
    if (!eventTitle || !eventTitle.value) {
        showWarning('Please enter an event title');
        resetSaveButton();
        return;
    }

    syncAllHiddenTimeFields();
    const formData = new FormData(document.getElementById('eventForm'));
    applyDefaultEndFields(formData);

    const startDateValue = formData.get('start_date');
    if (isPastDate(startDateValue)) {
        showWarning('Events cannot be created before today.');
        resetSaveButton();
        return;
    }
    
    // Log recurring event data if enabled
    const isRecurring = Boolean(isRecurringCheckboxEl && isRecurringCheckboxEl.checked);
    if (isRecurring) {
        console.log('üîÅ Saving recurring event with options:', {
            frequency: formData.get('frequency'),
            ends_on: formData.get('ends_on'),
            days: formData.getAll('days[]')
        });
        if (!formData.get('frequency')) {
            formData.set('frequency', 'monthly');
        }
        if (!formData.get('ends_on')) {
            formData.set('ends_on', 'never');
        }
    }
    
    try {
        const response = await fetch(eventUrls.create, {
            method: 'POST',
            body: formData,
        });
        
        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('‚ùå Non-JSON response:', text.substring(0, 500));
            throw new Error('Server returned an error page instead of JSON');
        }
        
        const result = await response.json();
        
        if (result.success) {
            // Close modal and update calendar
            const modalElement = document.getElementById('eventModal');
            if (modalElement) {
                const modal = bootstrap.Modal.getInstance(modalElement);
                if (modal) {
                    modal.hide();
                }
            }
            const newEvent = addNewEventToCalendarCache(formData, result.event_id);
            addNewEventToUpcomingList(formData, result.event_id);
            
            // Show success message with recurring info
            const message = isRecurring ? 
                'Recurring event created successfully!' : 
                'Event created successfully!';
            showToast(message, 'success');
        } else {
            showError(result.error);
        }
    } catch (error) {
        console.error('Error saving event:', error);
        showError('Error saving event: ' + error.message);
    } finally {
        resetSaveButton();
    }
}

function resetSaveButton() {
    const saveBtn = document.getElementById('saveEvent');
    if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.innerHTML = 'Save Event';
    }
}

function applyDefaultEndFields(formData, durationMinutes = 60) {
    const startDate = formData.get('start_date');
    const startTime = formData.get('start_time') || '09:00';
    if (!startDate) {
        return;
    }

    // Always lock the end date to the chosen start date since events are single-day.
    formData.set('end_date', startDate);

    const providedEndTime = formData.get('end_time');
    if (providedEndTime) {
        return;
    }

    if (!startTime) {
        return;
    }

    const sanitizedDuration = Number.isFinite(parseInt(durationMinutes, 10)) && parseInt(durationMinutes, 10) > 0
        ? parseInt(durationMinutes, 10)
        : 60;

    const [startHour, startMinute] = startTime.split(':').map(Number);
    const minutesPerDay = 24 * 60;
    const startMinutes = (startHour * 60) + startMinute;
    const maxMinutes = minutesPerDay - 1; // 23:59
    const totalMinutes = Math.min(startMinutes + sanitizedDuration, maxMinutes);
    const endHour = Math.floor(totalMinutes / 60);
    const endMinute = totalMinutes % 60;
    const endTimeStr = `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;

    formData.set('end_time', endTimeStr);
}

async function loadEventsForMonth() {
    try {
        const response = await fetch(`${eventUrls.getMonth}?year=${currentDate.getFullYear()}&month=${currentDate.getMonth() + 1}`);
        const result = await response.json();
        
        if (result.success) {
            currentEvents = result.events;
            renderCalendar();
        }
    } catch (error) {
        console.error('Error loading events:', error);
    }
}

function viewEventDetails(eventId) {
    openEventDetailsById(eventId);
}

function previousMonth() {
    currentDate.setMonth(currentDate.getMonth() - 1);
    updateCalendarHeader();
    loadEventsForMonth();
}

function nextMonth() {
    currentDate.setMonth(currentDate.getMonth() + 1);
    updateCalendarHeader();
    loadEventsForMonth();
}

function showToast(message, type = 'info') {
    // Simple toast notification
    const toast = document.createElement('div');
    toast.className = `alert alert-${type} alert-dismissible fade show`;
    toast.style.position = 'fixed';
    toast.style.top = '20px';
    toast.style.right = '20px';
    toast.style.zIndex = '9999';
    toast.style.minWidth = '300px';
    toast.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    document.body.appendChild(toast);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 3000);
}

</script>
{% endblock %}