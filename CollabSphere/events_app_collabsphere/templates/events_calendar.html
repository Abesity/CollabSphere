{% extends "base_dashboard.html" %}

{% load static %}

{% block title %}Events ‚Äì CollabSphere{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{% static 'css/sidebar.css' %}?v=1.0">
<link rel="stylesheet" href="{% static 'css/events_calendar.css' %}?v=1.0">
<link rel="stylesheet" href="{% static 'css/recurring_events.css' %}?v=1.0">
{% endblock %}

{% block extra_js %}
<script src="{% static 'js/sidebar.js' %}"></script>
<script src="{% static 'js/recurring_events.js' %}"></script>
{% endblock %}

{% block content %}
<div class="container-fluid calendar-container">
  <main class="calendar-main">
    
    <!-- Header Section -->
    <section class="calendar-header">
      <h1>Events Calendar</h1>
      <p>
        {% if team_name %}
          Managing schedule for <strong>{{ team_name }}</strong>
        {% else %}
          Manage your team's schedule and upcoming events
        {% endif %}
      </p>
      
      {% if not has_active_team %}
      <div class="alert alert-warning">
        <small>No active team selected. Please select a team to create and view events.</small>
      </div>
      {% endif %}
      
      <div class="calendar-controls">
        <div class="calendar-nav">
          <button class="btn-calendar" id="prevMonth">
            ‚Äπ Previous
          </button>
          <div class="current-month" id="currentMonth">Loading...</div>
          <button class="btn-calendar" id="nextMonth">
            Next ‚Ä∫
          </button>
        </div>
        <button class="btn-new" id="addEvent" {% if not has_active_team %}disabled title="Select a team to create events"{% endif %}>
          + New Event
        </button>
      </div>
    </section>

    <!-- Calendar Grid -->
    <section class="calendar-grid">
      <!-- Weekday Headers -->
      <div class="weekdays">
        <div class="weekday">Sunday</div>
        <div class="weekday">Monday</div>
        <div class="weekday">Tuesday</div>
        <div class="weekday">Wednesday</div>
        <div class="weekday">Thursday</div>
        <div class="weekday">Friday</div>
        <div class="weekday">Saturday</div>
      </div>
      
      <!-- Calendar Days -->
      <div class="calendar-days" id="calendarDays">
        <!-- Calendar will be populated by JavaScript -->
        <div class="loading-message">Loading calendar...</div>
      </div>
    </section>

    <!-- Upcoming Events Sidebar -->
    <section class="upcoming-events">
      <div class="card">
        <h3>Upcoming Events</h3>
        
        <div id="upcomingEventsList">
          {% for event in upcoming_events %}
          <div class="upcoming-item" data-event-id="{{ event.id }}">
            <div class="upcoming-date">
              <div class="upcoming-day">{{ event.day }}</div>
              <div class="upcoming-month">{{ event.month }}</div>
            </div>
            <div class="upcoming-details">
              <div class="upcoming-title">{{ event.title }}</div>
              <div class="upcoming-time">{{ event.time }}</div>
            </div>
            <div class="upcoming-actions">
              <span class="upcoming-type team">Team</span>
              <button type="button" class="btn-upcoming-delete" data-event-id="{{ event.id }}" aria-label="Remove event">
                <span class="btn-upcoming-delete-icon">&times;</span>
              </button>
            </div>
          </div>
          {% empty %}
          <div class="no-events">
            {% if has_active_team %}
              No upcoming events
            {% else %}
              Select a team to view events
            {% endif %}
          </div>
          {% endfor %}
        </div>
      </div>
    </section>

  </main>
</div>

<!-- Event Modal -->
<div class="modal fade" id="eventModal" tabindex="-1" aria-labelledby="eventModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="eventModalLabel">Create New Event</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="eventForm">
          {% csrf_token %}
          {% if team_name %}
          <div class="alert alert-info mb-3">
            <small>This event will be created for Team <strong>{{ team_name }}</strong></small>
          </div>
          {% endif %}
          
          <!-- Basic Event Information -->
          <div class="mb-3">
            <label for="eventTitle" class="form-label">Event Title *</label>
            <input type="text" class="form-control" id="eventTitle" name="title" required>
          </div>
          
          <div class="mb-3">
            <label for="eventDescription" class="form-label">Description</label>
            <textarea class="form-control" id="eventDescription" name="description" rows="3" placeholder="Optional event description..."></textarea>
          </div>
          
          <div class="row g-3 align-items-end">
            <div class="col-md-4">
              <label for="eventStartDate" class="form-label">Start Date *</label>
              <input type="date" class="form-control" id="eventStartDate" name="start_date" required>
            </div>
            <div class="col-md-4">
              <label for="eventStartTime" class="form-label">Start Time *</label>
              <input type="time" class="form-control" id="eventStartTime" name="start_time" value="09:00" required>
            </div>
            <div class="col-md-4">
              <label for="eventEndTime" class="form-label">End Time *</label>
              <input type="time" class="form-control" id="eventEndTime" name="end_time" value="10:00" required>
              <div class="form-text">Ends on the same day.</div>
            </div>
          </div>
          <input type="hidden" id="eventEndDate" name="end_date">
          
          <!-- ========================================== -->
          <!-- TASK 3.2.1: RECURRING EVENT OPTIONS START -->
          <!-- ========================================== -->
          
          <hr class="my-4">
          
          <div class="mb-3">
            <div class="form-check">
              <input type="checkbox" id="isRecurring" name="is_recurring" class="form-check-input">
              <label for="isRecurring" class="form-check-label fw-bold">
                üîÅ Recurring Event
              </label>
            </div>
          </div>

          <!-- Recurring Options Container (Hidden by default) -->
          <div id="recurringOptions" style="display: none;">
            
            <!-- Frequency Selection -->
            <div class="mb-3">
              <label for="frequency" class="form-label">Repeat Frequency</label>
              <select id="frequency" name="frequency" class="form-select">
                <option value="">Does not repeat</option>
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="monthly">Monthly</option>
                <option value="yearly">Yearly</option>
              </select>
            </div>

            <!-- Weekly Day Selector (Shows only for weekly frequency) -->
            <div class="mb-3" id="weeklyOptions" style="display: none;">
              <label class="form-label">Repeat on these days</label>
              <div class="btn-group d-flex" role="group" aria-label="Days of week">
                <input type="checkbox" class="btn-check" id="sun" name="days[]" value="0" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="sun">Sun</label>
                
                <input type="checkbox" class="btn-check" id="mon" name="days[]" value="1" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="mon">Mon</label>
                
                <input type="checkbox" class="btn-check" id="tue" name="days[]" value="2" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="tue">Tue</label>
                
                <input type="checkbox" class="btn-check" id="wed" name="days[]" value="3" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="wed">Wed</label>
                
                <input type="checkbox" class="btn-check" id="thu" name="days[]" value="4" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="thu">Thu</label>
                
                <input type="checkbox" class="btn-check" id="fri" name="days[]" value="5" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="fri">Fri</label>
                
                <input type="checkbox" class="btn-check" id="sat" name="days[]" value="6" autocomplete="off">
                <label class="btn btn-outline-primary btn-sm" for="sat">Sat</label>
              </div>
            </div>

            <!-- End Options -->
            <div class="mb-3">
              <label for="endsOn" class="form-label">Ends</label>
              <select id="endsOn" name="ends_on" class="form-select">
                <option value="never">Never</option>
                <option value="on">On a specific date</option>
                <option value="after">After a number of occurrences</option>
              </select>
            </div>

            <!-- End Date Field (Shows when "On date" is selected) -->
            <div class="mb-3" id="endDateField" style="display: none;">
              <label for="recurrenceEndDate" class="form-label">End Date</label>
              <input type="date" id="recurrenceEndDate" name="recurrence_end_date" class="form-control">
            </div>

            <!-- Occurrences Field (Shows when "After" is selected) -->
            <div class="mb-3" id="occurrencesField" style="display: none;">
              <label for="occurrences" class="form-label">Number of Occurrences</label>
              <input type="number" id="occurrences" name="occurrences" class="form-control" min="1" value="10" placeholder="e.g., 10">
              <div class="form-text">How many times should this event repeat?</div>
            </div>

            <!-- Recurrence Summary -->
            <div class="alert alert-info" id="recurrenceSummary" style="display: none;">
              <strong>üìÖ Summary:</strong> <span id="summaryText"></span>
            </div>

          </div>
          
          <!-- ======================================== -->
          <!-- TASK 3.2.1: RECURRING EVENT OPTIONS END -->
          <!-- ======================================== -->
          
          <div class="form-text mt-3">* Required fields. Start and end times are captured for the same calendar day.</div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="saveEvent">
          <span class="spinner-border spinner-border-sm d-none" role="status"></span>
          Save Event
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Day Action Modal -->
<div class="modal fade" id="dayActionModal" tabindex="-1" aria-labelledby="dayActionLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="dayActionLabel">Create an event for this day?</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-1">Would you like to schedule a new event on this date?</p>
        <div id="dayActionDate" class="text-muted small"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Not Now</button>
        <button type="button" class="btn btn-primary" id="confirmDayCreate">Create Event</button>
      </div>
    </div>
  </div>
</div>

<!-- Day Events Modal -->
<div class="modal fade" id="dayEventsModal" tabindex="-1" aria-labelledby="dayEventsLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="dayEventsLabel">Events on Selected Day</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="dayEventsDate" class="text-muted small mb-3"></div>
        <div id="dayEventsContainer" class="day-events-list"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Event Details Modal -->
<div class="modal fade" id="eventDetailsModal" tabindex="-1" aria-labelledby="eventDetailsLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="eventDetailsLabel">Event Details</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <h4 id="eventDetailsTitle" class="mb-2"></h4>
        <div id="eventDetailsTime" class="text-muted mb-3"></div>
        <p id="eventDetailsDescription" class="mb-0"></p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Delete Confirmation Modal -->
<div class="modal fade" id="confirmDeleteModal" tabindex="-1" aria-labelledby="confirmDeleteLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="confirmDeleteLabel">Remove Event</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="confirmDeleteMessage">
        Are you sure you want to remove this event?
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-danger" id="confirmDeleteButton">Yes, Remove</button>
      </div>
    </div>
  </div>
</div>

<script>
// Global variables
const initialYear = Number("{{ initial_year|default_if_none:'0' }}");
const initialMonth = Number("{{ initial_month|default_if_none:'1' }}");

let currentDate = new Date(initialYear || new Date().getFullYear(), (initialMonth || (new Date().getMonth() + 1)) - 1, 1);

let currentEvents = JSON.parse("{{ events_json|escapejs }}");
const hasActiveTeam = "{{ has_active_team|yesno:'true,false' }}" === 'true';
let pendingDayDateKey = null;
let pendingDeleteEventId = null;
let deleteCallback = null;
const dayActionModal = document.getElementById('dayActionModal');
const dayEventsModal = document.getElementById('dayEventsModal');
const eventDetailsModal = document.getElementById('eventDetailsModal');
const confirmDeleteModal = document.getElementById('confirmDeleteModal');
const modalInstances = {
    dayAction: null,
    dayEvents: null,
    eventDetails: null,
    deleteConfirm: null
};
const eventUrls = {
    create: "{% url 'create_event' %}",
    getMonth: "{% url 'get_events' %}",
    detailBase: "{% url 'get_event' 0 %}".replace(/0\/$/, ''),
    deleteBase: "{% url 'delete_event' 0 %}".replace(/0\/$/, '')
};
const CALENDAR_VIEW_STORAGE_KEY = 'collabsphere.calendar.view';

function loadStoredCalendarView() {
    try {
        const raw = localStorage.getItem(CALENDAR_VIEW_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (Number.isFinite(parsed?.year) && Number.isFinite(parsed?.month)) {
            return parsed;
        }
    } catch (err) {
        console.warn('Unable to read stored calendar view:', err);
    }
    return null;
}

function persistCalendarView(dateObj) {
    try {
        if (!(dateObj instanceof Date)) return;
        const payload = {
            year: dateObj.getFullYear(),
            month: dateObj.getMonth() + 1,
        };
        localStorage.setItem(CALENDAR_VIEW_STORAGE_KEY, JSON.stringify(payload));
    } catch (err) {
        console.warn('Unable to persist calendar view:', err);
    }
}

function initModalInstances() {
    if (typeof bootstrap === 'undefined' || !bootstrap.Modal) {
        console.warn('Bootstrap JavaScript is required for modals.');
        return;
    }
    modalInstances.dayAction = dayActionModal ? bootstrap.Modal.getOrCreateInstance(dayActionModal) : null;
    modalInstances.dayEvents = dayEventsModal ? bootstrap.Modal.getOrCreateInstance(dayEventsModal) : null;
    modalInstances.eventDetails = eventDetailsModal ? bootstrap.Modal.getOrCreateInstance(eventDetailsModal) : null;
    modalInstances.deleteConfirm = confirmDeleteModal ? bootstrap.Modal.getOrCreateInstance(confirmDeleteModal) : null;
}

function formatDateKey(year, monthIndex, day) {
    const month = String(monthIndex + 1).padStart(2, '0');
    const dayStr = String(day).padStart(2, '0');
    return `${year}-${month}-${dayStr}`;
}

function dayKeyToDate(dateKey) {
    const [year, month, day] = dateKey.split('-').map(Number);
    return new Date(year, month - 1, day);
}

function handleDaySelection(dateKey) {
    if (!hasActiveTeam) {
        showWarning('Select a team before creating events.');
        return;
    }
    const eventsForDay = getEventsForDate(dateKey);
    if (eventsForDay.length > 0) {
        showDayEventsModal(dateKey, eventsForDay);
    } else {
        showDayCreatePrompt(dateKey);
    }
}

function getEventsForDate(dateKey) {
    if (!Array.isArray(currentEvents)) return [];
    return currentEvents.filter(evt => normalizeDateKey(evt.start) === dateKey);
}

function normalizeDateKey(dateStr) {
    if (!dateStr) return '';
    if (dateStr.length === 10) return dateStr;
    return dateStr.split('T')[0];
}

function showDayCreatePrompt(dateKey) {
    pendingDayDateKey = dateKey;
    const dateDisplay = document.getElementById('dayActionDate');
    if (dateDisplay) {
        dateDisplay.textContent = dayKeyToDate(dateKey).toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
    }
    if (modalInstances.dayAction) {
        modalInstances.dayAction.show();
    }
}

function handleConfirmedDayCreate() {
    if (!pendingDayDateKey) return;
    const dateObj = dayKeyToDate(pendingDayDateKey);
    openEventModalForDate(dateObj);
    pendingDayDateKey = null;
    if (modalInstances.dayAction) {
        modalInstances.dayAction.hide();
    }
}

function openEventModalForDate(dateObj) {
    if (!dateObj) return;
    const isoDate = dateObj.toISOString().split('T')[0];
    const eventStartDate = document.getElementById('eventStartDate');
    const eventEndDate = document.getElementById('eventEndDate');
    const eventStartTime = document.getElementById('eventStartTime');
    const eventEndTime = document.getElementById('eventEndTime');
    if (eventStartDate) eventStartDate.value = isoDate;
    if (eventEndDate) eventEndDate.value = isoDate;
    if (eventStartTime) eventStartTime.value = '09:00';
    if (eventEndTime) eventEndTime.value = '10:00';
    const modalElement = document.getElementById('eventModal');
    if (modalElement) {
        const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
        modal.show();
    }
}

function showDayEventsModal(dateKey, events) {
    const container = document.getElementById('dayEventsContainer');
    const dateLabel = document.getElementById('dayEventsDate');
    if (dateLabel) {
        dateLabel.textContent = dayKeyToDate(dateKey).toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
    }
    if (container) {
        container.innerHTML = '';
        events.sort((a, b) => (a.start_time || '').localeCompare(b.start_time || ''));
        events.forEach(event => {
            const card = document.createElement('div');
            card.className = 'day-event-card';
            card.innerHTML = `
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <h6 class="mb-1">${event.title}</h6>
                            <div class="text-muted small">${event.start_time || ''} - ${event.end_time || ''}</div>
                        </div>
                        <button class="btn btn-link btn-sm p-0" data-event-id="${event.id || ''}">View</button>
                    </div>
                    <p class="mb-0 small text-muted mt-2">${event.description || 'No description provided.'}</p>
                </div>
            `;
            const viewBtn = card.querySelector('button[data-event-id]');
            if (viewBtn) {
                viewBtn.addEventListener('click', () => {
                    if (event.id) {
                        openEventDetailsById(event.id);
                    }
                });
            }
            container.appendChild(card);
        });
    }
    if (modalInstances.dayEvents) {
        modalInstances.dayEvents.show();
    }
}

async function openEventDetailsById(eventId) {
    if (!eventId) return;
    try {
        const response = await fetch(`${eventUrls.detailBase}${eventId}`);

        const result = await response.json();
        if (result.success && result.event) {
            populateEventDetailsModal(result.event);
        } else {
            showError(result.error || 'Unable to load event details');
        }
    } catch (error) {
        console.error('Error fetching event details:', error);
        showError('Unable to load event details');
    }
}

function populateEventDetailsModal(event) {
    const titleEl = document.getElementById('eventDetailsTitle');
    const timeEl = document.getElementById('eventDetailsTime');
    const descEl = document.getElementById('eventDetailsDescription');
    if (titleEl) titleEl.textContent = event.title || 'Untitled Event';
    if (timeEl) {
        timeEl.textContent = `${event.start_date || ''} ${event.start_time || ''} - ${event.end_date || ''} ${event.end_time || ''}`.trim();
    }
    if (descEl) descEl.textContent = event.description || 'No description provided.';
    if (modalInstances.eventDetails) {
        modalInstances.eventDetails.show();
    }
}

function formatTimeTo12Hour(timeValue) {
    if (!timeValue) return '';
    const [hourStr, minuteStr] = timeValue.split(':');
    let hour = parseInt(hourStr, 10);
    const minute = minuteStr || '00';
    const ampm = hour >= 12 ? 'PM' : 'AM';
    hour = hour % 12 || 12;
    return `${hour}:${minute} ${ampm}`;
}

function addNewEventToCalendarCache(formData, eventId) {
    if (!Array.isArray(currentEvents)) {
        currentEvents = [];
    }
    const startDate = formData.get('start_date');
    const endTime = formData.get('end_time');
    const startTime = formData.get('start_time');
    currentEvents.push({
        id: eventId,
        title: formData.get('title'),
        description: formData.get('description') || '',
        start: startDate,
        start_time: formatTimeTo12Hour(startTime),
        end_time: formatTimeTo12Hour(endTime),
        is_recurring: formData.get('is_recurring') === 'on'
    });
    renderCalendar();
}

function handleUpcomingListClick(event) {
    const deleteBtn = event.target.closest('.btn-upcoming-delete');
    const item = event.target.closest('.upcoming-item');
    if (deleteBtn) {
        const eventId = deleteBtn.dataset.eventId;
        if (eventId) {
            requestDeleteConfirmation(eventId, () => {
                if (item) {
                    item.remove();
                }
            });
        }
    } else if (item && item.dataset.eventId) {
        openEventDetailsById(item.dataset.eventId);
    }
}

function requestDeleteConfirmation(eventId, callback) {
    pendingDeleteEventId = eventId;
    deleteCallback = callback;
    if (modalInstances.deleteConfirm) {
        modalInstances.deleteConfirm.show();
    }
}

async function finalizeDeleteRequest() {
    if (!pendingDeleteEventId) return;
    const eventId = pendingDeleteEventId;
    try {
        await deleteEventById(eventId);
        if (deleteCallback) {
            deleteCallback();
        }
        deleteCallback = null;
        pendingDeleteEventId = null;
        if (modalInstances.deleteConfirm) {
            modalInstances.deleteConfirm.hide();
        }
    } catch (error) {
        console.error('Delete error:', error);
        showError('Failed to delete event.');
    }
}

async function deleteEventById(eventId) {
    const csrfToken = getCSRFToken();
    const response = await fetch(`${eventUrls.deleteBase}${eventId}/`, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': csrfToken || ''
        }
    });
    const result = await response.json();
    if (!result.success) {
        throw new Error(result.error || 'Delete failed');
    }
    currentEvents = currentEvents.filter(evt => String(evt.id) !== String(eventId));
    renderCalendar();
    loadEventsForMonth();
    showToast('Event removed', 'success');
}

function showWarning(message) {
    showToast(message, 'warning');
}

function showError(message) {
    showToast(message, 'danger');
}

function showInfo(message) {
    showToast(message, 'info');
}

document.addEventListener('DOMContentLoaded', function() {
    console.log('üü¢ Calendar DOM loaded');
    const storedView = loadStoredCalendarView();
    if (storedView) {
        currentDate = new Date(storedView.year, storedView.month - 1, 1);
    } else if (Number.isFinite(initialYear) && Number.isFinite(initialMonth) && initialYear > 0 && initialMonth > 0) {
        currentDate = new Date(initialYear, initialMonth - 1, 1);
    }

    initializeCalendar();
    initModalInstances();
    
    // Event listeners - check if elements exist first
    const prevMonthBtn = document.getElementById('prevMonth');
    const nextMonthBtn = document.getElementById('nextMonth');
    const addEventBtn = document.getElementById('addEvent');
    const saveEventBtn = document.getElementById('saveEvent');
    const startDateInput = document.getElementById('eventStartDate');
    const endDateInput = document.getElementById('eventEndDate');
    const confirmDayCreateBtn = document.getElementById('confirmDayCreate');
    const confirmDeleteBtn = document.getElementById('confirmDeleteButton');
    const upcomingList = document.getElementById('upcomingEventsList');
    
    if (prevMonthBtn) prevMonthBtn.addEventListener('click', previousMonth);
    if (nextMonthBtn) nextMonthBtn.addEventListener('click', nextMonth);
    if (addEventBtn) addEventBtn.addEventListener('click', showEventModal);
    if (saveEventBtn) saveEventBtn.addEventListener('click', saveEvent);
    if (startDateInput && endDateInput) {
        startDateInput.addEventListener('change', () => {
            if (startDateInput.value) {
                endDateInput.value = startDateInput.value;
            }
        });
    }
    if (confirmDayCreateBtn) {
        confirmDayCreateBtn.addEventListener('click', handleConfirmedDayCreate);
    }
    if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', finalizeDeleteRequest);
    }
    if (upcomingList) {
        upcomingList.addEventListener('click', handleUpcomingListClick);
    }
    
    // Always refresh the current month from the backend so the UI
    // stays in sync with live data (even if the initial payload was empty).
    loadEventsForMonth();
});

function getCSRFToken() {
    const name = 'csrftoken';
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.startsWith(name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    if (cookieValue && cookieValue.trim().length > 0) {
        return cookieValue.trim();
    }

    const formToken = document.querySelector('input[name="csrfmiddlewaretoken"]');
    if (formToken && formToken.value) {
        return formToken.value.trim();
    }

    const metaToken = document.querySelector('meta[name="csrf-token"], meta[name="csrfmiddlewaretoken"]');
    if (metaToken && metaToken.getAttribute('content')) {
        return metaToken.getAttribute('content').trim();
    }

    return null;
}

function initializeCalendar() {
    console.log('üü¢ Initializing calendar');
    updateCalendarHeader();
    renderCalendar();
}

function updateCalendarHeader() {
    const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"];
    const currentMonthElement = document.getElementById('currentMonth');
    if (currentMonthElement) {
        currentMonthElement.textContent = 
            `${monthNames[currentDate.getMonth()]} ${currentDate.getFullYear()}`;
    }
    persistCalendarView(currentDate);
}

function renderCalendar() {
    const calendarDays = document.getElementById('calendarDays');
    if (!calendarDays) {
        console.error('‚ùå Calendar days container not found');
        return;
    }
    
    calendarDays.innerHTML = '';
    
    const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
    const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
    const startingDayOfWeek = firstDay.getDay();
    const totalDays = lastDay.getDate();
    
    // Previous month days
    const prevMonthDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), 0);
    const prevMonthLastDay = prevMonthDate.getDate();
    for (let i = startingDayOfWeek - 1; i >= 0; i--) {
        const dayNum = prevMonthLastDay - i;
        const dateKey = formatDateKey(prevMonthDate.getFullYear(), prevMonthDate.getMonth(), dayNum);
        const dayElement = createDayElement(dayNum, true, false, dateKey);
        calendarDays.appendChild(dayElement);
    }

    // Current month days
    const today = new Date();
    for (let day = 1; day <= totalDays; day++) {
        const isToday = today.getDate() === day && 
                       today.getMonth() === currentDate.getMonth() && 
                       today.getFullYear() === currentDate.getFullYear();
        const dateKey = formatDateKey(currentDate.getFullYear(), currentDate.getMonth(), day);
        const dayElement = createDayElement(day, false, isToday, dateKey);
        calendarDays.appendChild(dayElement);
    }
    
    // Add events to days
    addEventsToCalendar();
}

function createDayElement(dayNumber, isOtherMonth, isToday = false, dateKey = null) {
    const dayElement = document.createElement('div');
    dayElement.className = 'calendar-day';
    if (isOtherMonth) dayElement.classList.add('other-month');
    if (isToday) dayElement.classList.add('today');
    const dateAttr = dateKey ? `data-date="${dateKey}"` : '';
    if (dateKey) {
        dayElement.dataset.dateKey = dateKey;
    }

    dayElement.innerHTML = `
        <div class="day-number">${dayNumber}</div>
        <div class="events-container" data-day="${dayNumber}" ${dateAttr}></div>
    `;
    
    if (!isOtherMonth) {
        dayElement.addEventListener('click', (event) => {
            const eventItem = event.target.closest('.event-item');
            if (eventItem && eventItem.dataset.eventId) {
                event.stopPropagation();
                openEventDetailsById(eventItem.dataset.eventId);
                return;
            }
            if (dayElement.dataset.dateKey) {
                handleDaySelection(dayElement.dataset.dateKey);
            }
        });
    }
    
    return dayElement;
}

function addEventsToCalendar() {
    if (!currentEvents || !Array.isArray(currentEvents)) {
        console.log('No events to display');
        return;
    }

    currentEvents.forEach(event => {
        const rawDate = normalizeDateKey(event.start);
        if (!rawDate) {
            return;
        }

        const parts = rawDate.split('-');
        if (parts.length !== 3) {
            return;
        }

        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10); // 1-based
        const day = parseInt(parts[2], 10);

        if (Number.isNaN(year) || Number.isNaN(month) || Number.isNaN(day)) {
            return;
        }

        if (year === currentDate.getFullYear() && month === (currentDate.getMonth() + 1)) {
            const dayElement = document.querySelector(`.events-container[data-date="${rawDate}"]`);
            if (dayElement) {
                const eventElement = document.createElement('div');
                eventElement.className = 'event-item team-meeting';
                if (event.id) {
                    eventElement.dataset.eventId = event.id;
                }

                const recurringIcon = event.is_recurring ? 'üîÅ ' : '';

                eventElement.innerHTML = `
                    <span class="event-time">${event.start_time}</span>
                    <span class="event-title">${recurringIcon}${event.title}</span>
                `;
                eventElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (event.id) {
                        openEventDetailsById(event.id);
                    }
                });
                dayElement.appendChild(eventElement);
            }
        }
    });

    const hasEvents = currentEvents.length > 0;
    const hasActiveTeam = '{{ has_active_team|yesno:"true,false" }}' === 'true';

    if (!hasEvents && !hasActiveTeam) {
        const calendarDays = document.getElementById('calendarDays');
        const message = document.createElement('div');
        message.className = 'no-team-message';
        message.style.gridColumn = '1 / -1';
        message.style.textAlign = 'center';
        message.style.padding = '2rem';
        message.style.color = '#6c757d';
        message.innerHTML = `
            <p>No active team selected. Please select a team to view and create events.</p>
        `;
        calendarDays.appendChild(message);
    }
}

function showEventModalForDay(day) {
    const startDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
    openEventModalForDate(startDate);
}

function showEventModal() {
    console.log('üü¢ Showing event modal');
    
    // Clear form and set default values
    const eventTitle = document.getElementById('eventTitle');
    const eventDescription = document.getElementById('eventDescription');
    const eventStartDate = document.getElementById('eventStartDate');
    const eventStartTime = document.getElementById('eventStartTime');
    const eventEndDate = document.getElementById('eventEndDate');
    const eventEndTime = document.getElementById('eventEndTime');
    
    if (eventTitle) eventTitle.value = '';
    if (eventDescription) eventDescription.value = '';
    
    const today = new Date();
    const todayIso = today.toISOString().split('T')[0];
    if (eventStartDate) eventStartDate.value = todayIso;
    if (eventStartTime) eventStartTime.value = '09:00';
    if (eventEndDate) eventEndDate.value = todayIso;
    if (eventEndTime) eventEndTime.value = '10:00';
    
    // Reset recurring options
    const isRecurringCheckbox = document.getElementById('isRecurring');
    if (isRecurringCheckbox) {
        isRecurringCheckbox.checked = false;
        document.getElementById('recurringOptions').style.display = 'none';
    }
    
    const modalElement = document.getElementById('eventModal');
    if (modalElement) {
        const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
        modal.show();
    }
}

async function saveEvent() {
    console.log('üü¢ Saving event...');
    
    const saveBtn = document.getElementById('saveEvent');
    if (!saveBtn) {
        console.error('‚ùå Save button not found');
        return;
    }
    
    // Show loading state
    saveBtn.disabled = true;
    saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Saving...';
    
    const eventTitle = document.getElementById('eventTitle');
    if (!eventTitle || !eventTitle.value) {
        showWarning('Please enter an event title');
        resetSaveButton();
        return;
    }

    const formData = new FormData(document.getElementById('eventForm'));
    applyDefaultEndFields(formData);
    
    // Log recurring event data if enabled
    const isRecurring = document.getElementById('isRecurring').checked;
    if (isRecurring) {
        console.log('üîÅ Saving recurring event with options:', {
            frequency: formData.get('frequency'),
            ends_on: formData.get('ends_on'),
            days: formData.getAll('days[]')
        });
    }
    
    try {
        const response = await fetch(eventUrls.create, {
            method: 'POST',
            body: formData,
        });
        
        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error('‚ùå Non-JSON response:', text.substring(0, 500));
            throw new Error('Server returned an error page instead of JSON');
        }
        
        const result = await response.json();
        
        if (result.success) {
            // Close modal and update calendar
            const modalElement = document.getElementById('eventModal');
            if (modalElement) {
                const modal = bootstrap.Modal.getInstance(modalElement);
                if (modal) {
                    modal.hide();
                }
            }
            addNewEventToCalendarCache(formData, result.event_id);
            
            // Show success message with recurring info
            const message = isRecurring ? 
                'Recurring event created successfully!' : 
                'Event created successfully!';
            showToast(message, 'success');
        } else {
            showError(result.error);
        }
    } catch (error) {
        console.error('Error saving event:', error);
        showError('Error saving event: ' + error.message);
    } finally {
        resetSaveButton();
    }
}

function resetSaveButton() {
    const saveBtn = document.getElementById('saveEvent');
    if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.innerHTML = 'Save Event';
    }
}

function applyDefaultEndFields(formData, durationMinutes = 60) {
    const startDate = formData.get('start_date');
    const startTime = formData.get('start_time') || '09:00';
    if (!startDate) {
        return;
    }

    // Always lock the end date to the chosen start date since events are single-day.
    formData.set('end_date', startDate);

    const providedEndTime = formData.get('end_time');
    if (providedEndTime) {
        return;
    }

    if (!startTime) {
        return;
    }

    const sanitizedDuration = Number.isFinite(parseInt(durationMinutes, 10)) && parseInt(durationMinutes, 10) > 0
        ? parseInt(durationMinutes, 10)
        : 60;

    const [startHour, startMinute] = startTime.split(':').map(Number);
    const minutesPerDay = 24 * 60;
    const startMinutes = (startHour * 60) + startMinute;
    const maxMinutes = minutesPerDay - 1; // 23:59
    const totalMinutes = Math.min(startMinutes + sanitizedDuration, maxMinutes);
    const endHour = Math.floor(totalMinutes / 60);
    const endMinute = totalMinutes % 60;
    const endTimeStr = `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;

    formData.set('end_time', endTimeStr);
}

async function loadEventsForMonth() {
    try {
        const response = await fetch(`${eventUrls.getMonth}?year=${currentDate.getFullYear()}&month=${currentDate.getMonth() + 1}`);
        const result = await response.json();
        
        if (result.success) {
            currentEvents = result.events;
            renderCalendar();
        }
    } catch (error) {
        console.error('Error loading events:', error);
    }
}

function viewEventDetails(eventId) {
    openEventDetailsById(eventId);
}

function previousMonth() {
    currentDate.setMonth(currentDate.getMonth() - 1);
    updateCalendarHeader();
    loadEventsForMonth();
}

function nextMonth() {
    currentDate.setMonth(currentDate.getMonth() + 1);
    updateCalendarHeader();
    loadEventsForMonth();
}

function showToast(message, type = 'info') {
    // Simple toast notification
    const toast = document.createElement('div');
    toast.className = `alert alert-${type} alert-dismissible fade show`;
    toast.style.position = 'fixed';
    toast.style.top = '20px';
    toast.style.right = '20px';
    toast.style.zIndex = '9999';
    toast.style.minWidth = '300px';
    toast.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    document.body.appendChild(toast);
    
    // Auto remove after 3 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 3000);
}

</script>
{% endblock %}